I> Resources for algorithm practice:  
> https://projecteuler.net/archives  
> https://leetcode.com/  

Algorithm, I'm coming to you know.

Bascially, algorithm is smart method to solve some kind of problems.
You can combine several method together to solve a particular problem.
There are many classical algorithms. They are just like `+` `-` `*` `/` in arithmatic operations.
All you need is to understand them, and put them into your dailylife usage.
As it requires some kind of thinking. You may want to give up at the beginning.
But, just take it easy, and try understanding what does the methodology do, with your initialality.

# Chapter 1
### General Introduction

What does matter, no matter the language, is how your program scales. If you double the size of your input, what happens?
Will your program run for twice as long? Four times? More?  
Will the running time double even if you add just one measly bit to the input?  
These are the kind of differences that will easily trump language or hardware choice, if your problem get big enough.  
Your main weapon in whittling down the growth of your running time is--you guessed it--a solid understanding of algorithm design.  

**Summary**
Programming isn't just about software architecture and object-oriented design;  
it's also about solving alogrithmic problems, some of which are really hard.  
For the more ordinary problems(such as finding the shortest path from A to B),  
the algorithm you use or design can have a huge impact on the time your code takes to finish,  
and for the hard problems(such as finding the shortest route through A-Z,  
there may not even be an efficient algorithm, meaning that you need to accept approximate solutions.  

This book will teach you several well-known algorithms,  
along with general principles that will help you create your own.  
Ideally, this will let you solve some of the more challenging problems out there,  
as well as create programs that scale gracefully with problem size.

If you want to really sharpen your algorithm design skills,  
you might also want to check out some of the myriad sources of programming puzzles out there.  
There are, for example, lots of progrmming contests (a web search should turn up plenty),  
many of which post problems that you can play with.  
Many big software companies also have qualification tests based on problems such as these and publish some of them online.




# Chapter 2
After reading this chapter, you should be clear on the meaning of phrases such as "directed, weighted graph without negative cycles" and "a running time of Î˜(n lgn)































Travesal


Recursion


Divide and Conquer


Greedy


Bisect
