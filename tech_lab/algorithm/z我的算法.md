## 为什么学习算法
2015-08-19 14:58

一年多前，我便想学习python算法，但是因为种种原因，总是半途而废。

曾举臣说：“在你最害怕的事情后面，往往隐藏着你最渴望的财富。”

所以，这一回，我抱着和看`<cien soledad>`一样的心态，重新开始学习算法。

一种坚韧的耐心。

`本笔记，只写下我自己对算法的理解`, 不理解的东西，我会留下相关链接，但不会记录。

目前，我的理解是，算法是一种用来解决问题的办法，在电子计算机上，它表现为一系列的逻辑指示。  
而有一些构建这些逻辑指示的思维方法非常精妙，但人脑不易直觉感知，需要通过耐心的训练才能体会。  
这些算法对于解决我们在生活中遇到的各类问题会有帮助。所以我们学习它。  
从另外一些角度而言，学习这些算法（思维方式）也有利于开拓我们对世界的认知方式。

## 衡量算法的效率
对待同一个问题，可能有多个解决方案。但是多个解决方案之间，效率上是会存在差异的。  
有的解决方案相比其他方案而言，在相同的硬件配置下，使用更少的时间就可以达到目的。这一类算法在运行时间上有优势。  
但这并不是唯一的评价标准。有的时候，你的算法非常棒，在有4G内存的条件下，1秒钟就能出结果。  
可是，对不起。我们小店机器差，只有1G内存。大哥你的算法在1G内存的情况下可以运行不？一天内能出结果就行。  
什么，不行？对不起，再见。我们不需要运行不了的算法。  
所以，另一个评判算法的标准是，在某一个运行时间范围内和硬件条件限制下，所需系统资源最少。  

所以一个美好的算法就是：用的系统资源少，运行速度快，而且可以有效解决问题？

没错，等等。

如果我们遇到过一个问题的话，那么极有可能，我们还会遇到第二遍。而且第二遍的情况可能会和第一遍的情况有差异。  
比如，原始的任务是将10个词按出现频率排序，在同样的条件下，算法1用了0.1秒，而算法2用了0.5秒。  
算法1更好，你说。  
领导来了，告诉你刚才只是让你练下手，你真正的任务是给一本百万词的书按出现频率排序。  
在真实任务下，你使用算法1，花了十万秒，而算法2只花了300秒。  
任务进一步扩大，书籍变成千万词的规模，算法1花了一百万秒，而算法2, 960秒。  
我们可以看出，随着问题规模的扩大，算法2解决问题所需时间的增长比算法1要慢得多。  
我们可以计算出在某一固定硬件条件下，随着问题规模变大，一个算法其计算所需时间增长的速度。  
这个增长速度越慢的算法，越好。

同样的，有一些算法在问题规模变大后，所需的系统资源会急剧增加（笔者就曾遇到这种情况，最后导致进程被杀死）。  
所以，随着问题规模增大，所需系统资源增长速度越慢的算法，越好。

一个真正优秀的算法，是在解决初始问题时所需时间和系统资源都少，然后在问题规模扩展时，所需运行时间和所需系统资源增长速度都很低的算法。
