P1   ****************************************************************************************


working area, stage area, and git area are 3 separated file systems.

For example:
You got a file1, its content is "Hello world"
You used "git add file1" to stage it, no you have git status "change for commit: modified: file1 "

Now you add a line "Bye, world" in file1.
Doing "git status", you will got:
"change for commit: modified: file1 "
"change not prepared for commit: modified: file1 "

So there are two files in two different area now.

But of course, when you use "vim file1" to edit, if there are modified content not added, you will see
them first, the working area file is on the top layer.
You can use "git checkout file1" to remove all the current changes in working area. The modified content in the stage area will not be affected by this command.


Assuming you have a file1 in a branch named 'branch1', its content is "Jambalaya",
now you checkout from master to this branch1 with the staged file1, you will meet an Aborting error.
Because this staged file1 will have conflict with the commited file1 in branch1.
So what if I make another branch from master at this moment?
After 'git branch branch2' You will find 'Hello world' in it. Then you check back to master, reset file1 and checkout it later. You will find an empty file1 in master, then you back to branch1, you will find file1 is empty there, too. Which means "When you made a new branch, what do you do is to copy all the commited file from the source branch. Yes, staged files and modified files are shared between branches, as if there is not a commit file with same name in the targeted checkout branch."




P2   ****************************************************************************************

master branch does not have something special with others, it is just a branch generated by git in default, so most people did not bother to change it

When doing divergent branch merges, it is actually a three-way merge, two commits the two branches are pointed to and their common ancestor commit went together to the commit process.

When a branch is losing its functionality, you should delete it. Generally delete all topic branches when you merged them into main branch.

Before push to origin, see if in local we got editing file or staged file.

In a git commit message, words precedes with a "#" won`t be show, other messages will be shown, In some important commits, it is good to write a nice commit message.

git fetch only fetch reomte data, git pull will fetch and merge automatically merge it

For example:
    You got a local master, which has a file "A" in it. Then you add a remote named "origin" using "git remote add Tank git@sample.com:user/Tank.git", now nothing happend yet, you just add a source to your target list.
    At this point 1. You  using  "git fetch", then you find you can check to "origin/master" now, but your locale master file is untouched. Be aware, if you using git fetch without specified remote, it`ll fetch from "origin"
    Back to point 1. If you do "git pull origin master", you`ll fetch file from origin/master and then merge it into your local master. Without parameters, 'git pull' will pull the default upstream-remote branch of the local branch.
    So, 'git fetch' just fetch the remote stats, 'git pull' do the fetch and merge it with your local stats.


When Cloning a repository, git will creates a 'master' branch automatically which tracks 'origin/master'


P3  ******************************************************************************************

There are two ways to merging diverged commits, the first one is 'merge', and the second one is 'rebase'.

'Merge' find the common ancestor of two commits, and do a three way merge. 'Rebase' directly imply the changes of one commits on another.

There is no difference between the end result of 'Merge' and 'Rebase', But 'Rebase' can give you a cleaner linear log history.

'Rebase' happens like this, first you rewind back to the common ancestor of two branches, then all the changes from the ancestor to current branch will be recored linear in a temporary file. Then your current branch will be set to the last commit
of the target branch, then, apply all the changes stored in the temp file by their order on this commit of target branch. Then you`ll got a "target branch commit + all commit changes by order from ancestor to current branch" commit. This commit
is where your current branch resides. And with no-doubt, it is a newer commit at this same flow with the target branch. And you check back to your target branch, merge it with your previosu branch, then a fast-forward merge will be made.

!!!
    DO NOT REBASE COMMITS THAT EXIST OUTSIDE YOUR REPOSITORY
!!!

In git, except the SHA-1 checksum, there is also a patch-id to track each commit changes. So in different commit, there may contain the same ptach change, such as a rebased commit may have the same change content as its origin commit.


P4  ******************************************************************************************

A commit encapsultaes:

* all parent object ids

* author name, email and date

* commiter name and email and the commit time













