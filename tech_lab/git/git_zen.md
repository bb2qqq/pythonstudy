P1   ****************************************************************************************



working area, stage area, and git area are 3 separated file systems.

For example:
You got a file1, its content is "Hello world"
You used "git add file1" to stage it, no you have git status "change for commit: modified: file1 "

Now you add a line "Bye, world" in file1.
Doing "git status", you will got:
"change for commit: modified: file1 "
"change not prepared for commit: modified: file1 "

So there are two files in two different area now.

But of course, when you use "vim file1" to edit, if there are modified content not added, you will see
them first, the working area file is on the top layer.
You can use "git checkout file1" to remove all the current changes in working area. The modified content in the stage area will not be affected by this command.


Assuming you have a file1 in a branch named 'branch1', its content is "Jambalaya",
now you checkout from master to this branch1 with the staged file1, you will meet an Aborting error.
Because this staged file1 will have conflict with the commited file1 in branch1.
So what if I make another branch from master at this moment?
After 'git branch branch2' You will find 'Hello world' in it. Then you check back to master, reset file1 and checkout it later. You will find an empty file1 in master, then you back to branch1, you will find file1 is empty there, too. Which means "When you made a new branch, what do you do is to copy all the commited file from the source branch. Yes, staged files and modified files are shared between branches, as if there is not a commit file with same name in the targeted checkout branch."




P2   ****************************************************************************************

master branch does not have something special with others, it is just a branch generated by git in default, so most people did not bother to change it

When doing divergent branch merges, it is actually a three-way merge, two commits the two branches are pointed to and their common ancestor commit went together to the commit process.

When a branch is losing its functionality, you should delete it. Generally delete all topic branches when you merged them into main branch.

Before push to origin, see if in local we got editing file or staged file.

In a git commit message, words precedes with a "#" won`t be show, other messages will be shown, In some important commits, it is good to write a nice commit message.

git fetch only fetch reomte data, git pull will fetch and merge automatically merge it

For example:
    You got a local master, which has a file "A" in it. Then you add a remote named "origin" using "git remote add Tank git@sample.com:user/Tank.git", now nothing happend yet, you just add a source to your target list.
    At this point 1. You  using  "git fetch", then you find you can check to "origin/master" now, but your locale master file is untouched. Be aware, if you using git fetch without specified remote, it`ll fetch from "origin"
    Back to point 1. If you do "git pull origin master", you`ll fetch file from origin/master and then merge it into your local master. Without parameters, 'git pull' will pull the default upstream-remote branch of the local branch.
    So, 'git fetch' just fetch the remote stats, 'git pull' do the fetch and merge it with your local stats.


When Cloning a repository, git will creates a 'master' branch automatically which tracks 'origin/master'
